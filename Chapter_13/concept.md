## 中断及其分类

​	按中断事件的来源和实现手段可把中断源分成：硬中断和软中断。硬中断又分外中断和内中断。外中断又称中断或异步中断，是指来值CPU以外的中断信号，外中断还可分屏蔽中断和不可屏蔽中断，不同中断具有不同的中断优先级，表示事件的紧急程度，在处理高级中断时，往往会屏蔽部分或全部低级中断。内中断又称异常或同步中断，是指来自CPU内部，在程序执行中，发现的与当前指令关联的、不正常的或错误的事件。Linux中的异常可被细分为4种：故障（fault）、陷阱（trap）、终止（abort）和编程异常（programmed excption）。

* “中断”（硬中断）用于外部设备对CPU的中断（中断的是正在运行的任何程序），转向中断处理程序上半部分执行。
* “异常”（硬中断）因指令执行不正常而中断CPU（中断的是正在执行这条指令的程序），转向异常处理程序。
* “软件中断”（软中断）用于硬中断副服务程序对内核的中断，在上半部分中发出软件中断（即标记bottom half），使得中断下半部分在适当时刻获得处理。
* “信号”（软中断）用于内核或进程对某个进程的中断，通知进程某个特定事件发生或迫使进程执行信号处理程序。

​	操作系统中，除一部分低层硬件异常由内核异常处理程序处理外，大部分异常均转化为信号（软中断）再进行处理，由于异常与当前运行进程紧密相关，每当执行指令产生异常事件，可通过信号处理程序向当前运行进程发出一个信号。

## 上半部分和下半部分

​	中断通常由硬件设备引发，与异常的处理有一定差异，在响应一个特定中断的时候，内核会执行中断处理程序（或称中断服务例程）。产生中断的每个设备都有一个相应的中断处理程序，例如，时钟中断处理程序、键盘中断处理程序。一个设备的中断处理程序是它的设备驱动程序的一部分，而设备驱动程序是用于对设备进行管理的内核代码。

​	在Linux中，中断处理程序必须按照特定的类型声明，以便内核能够以标准方式传递处理程序的信息，中断处理程序与其他内核函数的真正区别在于：中断处理程序是被内核调用来响应中断的，它们运行于称为中断上下文的特殊上下文中。

​	中断可能随时发生，因此中断处理程序也就随时可能执行，必须让中断处理程序能够快速执行，这样才能保证尽可能快地恢复被中断代码的执行。为此把中断处理程序分为上半部分（top half）和下半部分（bottom half），上半部分接收到一个中断后，它就立即开始执行，只做有严格时间限制的工作，如对接收的中断进行响应或复位硬件，这些工作都是在所有中断被禁止的情况下完成的；能够被允许稍后完成的工作会推迟到下半部分中去，在合适的时机，下半部分会被开中断执行。

## 中断和异常的一般处理过程

​	Linux中断机制在保护模式下的实现采用中断描述符表IDT（Interrupt Descriptor Table），该表包含256个中断描述符，每个中断或异常对应一个。描述符的作用是把程序控制转给中断/异常服务程序，每个均为8B，通过它就能找到中断/异常服务程序的起始地址、属性及程序特权级等信息。IDT的位置由硬件中断描述符表寄存器IDTR指定，它是个48位的寄存器，高32位是IDT的基址，低16位限定IDT的长度。当产生中断时，CPU响应中断请求后，硬件将自动清除中断允许位，以禁止其他硬件中断；但对于异常，启动异常处理程序后系统并不关中断，允许响应中断并暂时中止异常处理。

​	每个中断/异常都有一个向量号，该号的值在0～255之间，该值是中断在IDT表中的索引，每个中断/异常均有其相应处理程序，中断在使用前，必须在IDT中注册以保证发生中断时能找到相应处理程序。IDT在系统初始化时创建，向量的使用情况为：0～31号对应异常或硬件非屏蔽中断，32～47号分配给可屏蔽硬件中断，48～255号中断向量分配给软件中断，其中，128号（0x80）用来实现系统调用。

​	中断处理执行流程大致如下：

1. 当设备发出中断请求时，中断信号由设备发送到中断控制器，中断控制器根据IRQ号转换成中断量号传给CPU；CPU响应中断后，自动保护现场信息，把PSW（EFLAGS、CS和EIP）、中断向量号、用户栈段寄存器SS和栈指针ESP压入内核栈，并根据向量号查IDT，生成指向中断描述符表的指针，找到对应中断服务程序IRQn_interrupt的地址，中断处理程序开始执行。
2. 进入中断公共代码段common_interrupt处执行SAVE_ALL，保护所有硬件未保护的寄存器内容到内核栈。
3. 调用do_IRQ()函数，对中断控制器进行确认，设置中断源状态等。
4. 根据IRQ为发出中断请求的设备提供服务，调用服务程序执行相关中断处理任务，标记中断下半部分；如果有多个设备共享该中断IRQ，需执行该中断线上所有的中断服务程序。
5. 检查softrq_active和softirq_mask是否有标记的下半部分，有就调用so_softirq()执行之。
6. 跳转到ret_from_intr退出，恢复中断前的现场。

​	异常处理分3步：一是当前进程执行指令产生异常；二是进入并执行异常处理程序；三是从异常处理程序返回。当异常产生时，将触发0～31号对应的异常，并自动转向异常处理程序公共入口执行，执行下列操作：

1. 将硬件错误码和异常向量号存入当前进程PCB中。
2. 判别异常产生于内核态还是用户态，对于前者，将简单第转向内核预定义服务程序处理，没有处理的内核态异常时操作系统的致命错误。
3. 对于用户态异常，终止当前进程运行，调用force_sig()函数给当前进程发信号。
4. 从ret_from_exception处返回用户空间时，将会检查进程是否有信号等待处理，如果有则根据信号类型调用相应函数进行处理。

​	当然，也有些异常处理很特殊，如页面故障异常，它是实现分页虚存管理的硬件支撑，由系统来处理这种异常，异常处理程序最终会转向do_page_fault()执行页面调度。

​	中断和异常处理过程大致相同，但产生异常时，硬件并不清除中断标志位，此时还允许外部硬件中断；而产生中断时，硬件立即清除中断标志位，以禁止其他硬件中断。