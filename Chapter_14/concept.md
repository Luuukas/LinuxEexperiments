## 等待队列

​	内核在管理进程时，需要把处于不同状态的进程进行分类组织。处于可运行态的进程被组织在一起。暂停态和僵死态的进程不链接在专门的链表中。等待态的进程再分成很多类，每一类对应一个特定的事件。处于同一类等待态的进程通过等待队列链接在一起。等待队列实现了在事件上的条件等待：希望等待特定事件的进程把自己放进适合的等待队列，并放弃CPU。等待队列表示一组睡眠的进程，当某一条件变成真时，由内核唤醒睡眠的进程。

### 数据结构

​	等待队列由循环链表实现，其元素包括指向进程描述符的指针。每一个等待队列都有一个等待队列头（wait queue head），等待队列头是一个类型为wait_queue_head_t的数据结构，内核中定义在\<linux/wait.h\>文件中：

```c
struct _wait_queue_head{
    spinlock_t lock;
    struct list_head task_list;
};
typedef struct _wait_queue_head wait_queue_head_t
```

​	在该数据结构中，lock成员为自旋锁，它保证多个CPU不会同时修改等待队列；task_list是用于实现双向链表的数据结构。开发者可以通过DECLARE_WAIT_QUEUE_HEAD静态定义并初始化一个wait_queue_head_t，也可以使用init_waitqueue_head()动态初始化。

​	等待队列中的每个元素为wait_queue_t类型，该数据结构也定义在\<linux/wait.h\>文件中：

```c
struct _wait_queue{
    unsigned int flags;
    #define WQ_FLAG_EXCLUSIVE 0x01
    void *private;
    wait_queue_func_t func;
    struct list_head task_list;
};
typedef struct _wait_queue wait_queue_t;
```

​	等待队列链表中的每个元素代表一个睡眠进程，该进程等待某一事件发生，其描述符地址存放在private成员中。在同一等待队列中的所有进程都在等待同一个事件的发生，当该事件发生时，内核唤醒所有进程是合理的。但是在有些情况下，如果多个进程等待的资源只能互斥地被访问，唤醒所有进程会浪费系统资源；因为只有一个进程能够获得资源，被唤醒的其他进程仍必须进入睡眠。wait_queue_t数据结构中的flag用于区分这两种情况，当flag设置为1时，内核有选择性地唤醒进程；如果flag设置为0，内核会将所有进程唤醒。func成员指定进程被唤醒后执行的函数。开发者可以使用DECLARE_WAIT_QUEUE静态定义并初始化一个wait_queue_t，也可以使用init_waitqueue_entry()来初始化。默认的初始化将flag设为0，private设为要睡眠的进程的进程描述符，而func则初始化为函数default_wake_func()指针，该函数只是调用try_to_wake_up()来唤醒等待队列项对应的进程。

​	等待队列中的元素还可以采用DEFINE_WAIT宏进行声明。该宏将private设置为当前进程，将func设置为autoremove_wake_function()。autoremove_wake_function()将调用default_wake_function()，并将该等待队列元素从等待队列中删除。开发者在定义好等待队列元素后，可以使用内核提供的函数直接对等待队列进行操作。

* add_wait_queue()：将一个非互斥进程插入等待对列。
* add_wait_queue_exclusive()：将一个互斥进程插入等待队列。
* remove_wait_queue()：将一个进程从等待队列中删除。
* waitqueue_active()：检查等待队列是否为空。

### 睡眠进程

### 唤醒进程

## Linux内核的并发性和同步机制

​	操作系统内核执行过程中，以下原因会造成并发执行：

* 中断可能在任何时刻异步发生，随时可能打断正在执行的内核代码。
* 内核调度tasklet和softirq，打断当前正在执行的代码。
* 如果内核具有抢占性，运行的内核任务会被另一个任务抢占。
* 进程被阻塞时，会唤醒调度程序工作，引起其他进程运行。
* SMP平台上，两个或多个CPU同时执行内核代码，可能访问同一共享数据结构。

​	这就要求有同步机制来保证不出现竞争条件，在中断处理程序中能避免发生访问的安全代码称作中断安全代码、在SMP的计算机中能避免并发访问的安全代码称SMP安全代码、在内核抢占时能避免并发访问的安全代码称抢占安全代码。Linux提供多种内核同步机制避免上述竞争条件，实现各种内核安全代码。

### 原子操作

​	原子操作保证在执行过程中不被打断，以防止发生简单的竞争条件，确保操作结果的正确性，**复杂的锁机制能在原子操作基础上构建**。Linux内核定义两类原子操作。

1. 原子整数操作
2. 原子位图操作

### 内核信号量

​	在Linux内核中为，也使用等待队列来实现信号量机制，内核信号量semaphore定义为：

```c
struct semaphore{
    atomic_t count;
    int sleepers;
    wait_queue_head_t wait;
};
```

​	资源计数器count表示可用的某种资源数，若为正整数则尚有这些资源可用；若为0或负整数则资源已用完，且因申请资源而等待的进程有count绝对值个。sema_init宏用于初始化count为任何值，可以是二元信号量，也可以是一般信号量；在Down操作中，count减1后的值若小于0，进程便进入等待队列。Up操作中，count加1后的值如果大于0，立即唤醒等待队列中的所有进程。

* sleepers对等待当前临界资源的进程个数进行辅助计数。
* wait用于存放等待队列链表的地址，该链表包含当前正在等待该信号量（资源）而被阻塞的所有进程。

### 内核等待队列

​	Linux内核信号量采用非忙式等待实现，当进程执行Down操作而等待时，将放入等待信号量队列；事实上，并发进程同步时，只要等待条件不满足，就必须挂起，放入相应等待队列。所以，等待队列是支持进程同步的重要数据结构，其定义为：

```c
struct wait_queue{
    unsigned int compiler_warning;
    struct task_struct *task;	// 指向等待进程的PCB
    struct list_head task_list;    // 等待队列链表
};
```

​	**内核等待队列也是临界资源，修改时应加锁，以避免竞争条件**。内核为每个事件都设立一个等待队列，若等待一个指定事件发生时，它必须调用add_wait_queue()把自己加入该事件等待队列，并通过schedule()交出CPU。等待事件发生后，内核调用remove_wait_queue()将一个进程从等待队列中移出。

### 关中断

​	一个正在对内核数据结构操作的进程可以被I/O设备中断，**如果设备中断处理程序恰好也要访问该数据结构**，就会引起系统的不一致状态，解决这类问题的有效方法是关中断。关中断是把内核态执行的程序段作为临界区来保护的一种手段，主要保护中断处理程序也要访问的数据结构，如磁盘中断就需要被屏蔽，此外，**关中断还能禁止内核抢占**。**为了防止死锁，关中断期间内核不能执行阻塞操作**。在SMP环境中，**关中断只能防止来自本机其他中断处理程序的并发访问**，需要引入自旋锁在禁止本地中断的同时，防止来自本机其他中断处理程序的访问，需要引入自旋锁在禁止本地中断的同时，防止来自它机的并发访问。

### 自旋锁

​	原子操作能保证对变量操作的原子性，例如，原子加操作，把读取和增加变量的动作包含在一个单步中执行，从而防止发生竞争。可是临界区却不像增加变量这样简单，有时它可以跨越多个函数。例如，先从一个数据结构中读出数据，对其进行格式转换和解析，再把它写到另一个数据结构中。整个执行过程必须是原子的，在数据被更新完毕前，不能有其他代码读取这些数据。显然，简单的原子操作对此无能为力，这就需要使用更为复杂的同步方法——锁，来提供保护。

​	Linux内核中最常见的锁是自旋锁，自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个已经被锁住的自旋锁，那么该线程就会一直进行忙式等待（旋转），等待锁重新可用，期间该CPU不能再处理其他工作，同时等待其他CPU上运行的进程执行解锁操作，要是锁未被争用，请求锁的执行线程便能立即锁住它，继续执行。再任意时刻，自旋锁都可以防止多于一个的执行线程同时进入临界区。

​	自旋锁是最简单的一种锁原语，锁的取值为0表示资源可用，锁的取值为1表示资源加载。自旋锁很像二元信号量，但在实现上有区别，若一个资源得到自旋锁的保护，另一个试图取得该资源的内核例程将保持忙式等待，直到资源被解锁。而在实现二元信号量时，不必循环等待信号量，而是进入等待队列，暂时放弃对资源的请求。

​	因为自旋锁在同一时刻至多被一个执行线程持有，所以一个时刻只能有一个线程位于临界区内，这就为SMP计算机提供防止并发访问所需的保护机制。在单CPU计算机上，编译操作系统并不会加入自旋锁，它仅仅被当作一个设置内核抢占机制是否被开启的开关，如果禁止内核抢占，那么在编译时会被完全剔出内核。

​	自旋锁同样用来标记只能有一个线程访问该对象，在同一线程多次加锁操作会造成死锁；**使用硬件提供的swap指令或test_and_set指令实现**；同互斥锁不同的是在锁操作需要等待的时候并不是睡眠等待唤醒，而是循环检测保持者已经释放了锁，这样做的好处是节省了线程从睡眠状态到唤醒之间内核会产生的消耗，在加锁时间短暂的环境下这点会提高很大效率。

​	自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。

​	在单处理机环境中可以使用特定的原子级汇编指令swap和test_and_set实现进程互斥，这些指令涉及对同一存储单元的两次或两次以上操作，这些操作将在几个指令周期内完成，但由于中断只能发生在两条机器指令之间，而同一指令内的多个指令周期不可中断，从而保证swap指令或test_and_set指令的执行不会交叉进行。

​	但在多处理机环境中情况有所不同，例如test_and_set指令包括“取”、“送”两个指令周期，两个CPU执行test_and_set(lock)可能发生指令周期上的交叉，假如lock初始为0, CPU1和CPU2可能分别执行完前一个指令周期并通过检测(均为0)，然后分别执行后一个指令周期将lock设置为1，结果都取回0作为判断临界区空闲的依据，从而不能实现互斥.。

​	为在多CPU环境中利用test_and_set指令实现进程互斥，硬件需要提供进一步的支持，以保证test_and_set指令执行的原子性. 这种支持多以**“锁总线”(bus locking)**的形式提供的，由于test_and_set指令对内存的两次操作都需要经过总线，在执行test_and_set指令之前锁住总线，在执行test_and_set指令后开放总线，即可保证test_and_set指令执行的原子性。